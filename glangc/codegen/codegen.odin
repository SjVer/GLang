package glangc_codegen

import "core:strings"
import "core:time"

import c "../common"
import r "../report"
import t "../typing"

import g "generator"
import "generators"

TARGET_GENERATORS: map[string]g.Generator = {
	c.C_TARGET.name           = generators.C_GENERATOR,
	c.GLSL_300_ES_TARGET.name = generators.GLSL_300_ES_GENERATOR,
	c.GLSL_410_TARGET.name    = generators.GLSL_410_GENERATOR,
}

gen_code :: proc(
	tast: t.TAST,
	target: c.Target,
	options: map[string]string,
) -> string {
	assert(target.name in TARGET_GENERATORS, "nonexistent generator")
	gen := TARGET_GENERATORS[target.name]

	// set things up
	gen.target = target
	gen.options = options
	gen.builder = strings.builder_make()
	gen.indent_level = 0
	gen.indent_str = "    "

	// prelude
	g.gprintfcln(&gen, "Generated by glangc")
	year, month, day := time.date(time.now())
	hours, mins, secs := time.clock_from_time(time.now())
	g.gprintfcln(
		&gen,
		"time: %02d-%02d-%04d %02d:%02d:%02d",
		day,
		month,
		year,
		hours,
		mins,
		secs,
	)
	g.gprintfcln(&gen, "target: %s", gen.target.name)
	g.gprintfcln(&gen, "see: https://github.com/SjVer/GLang")
	gen.gen_prelude(&gen)

	// codegen for each TAST item
	for decl in tast.decls {
		g.gprintln(&gen)
		g.gprintfln(&gen, gen.comment_fmt, r.span_to_string(decl.span, true))

		switch decl in decl.decl {
			case t.Builtin:
				gen.gen_builtin(&gen, decl)
			case t.Global:
				gen.gen_global(&gen, decl)
			case t.Function:
				gen.gen_function(&gen, decl)
		}
	}

	// epilogue
	gen.gen_epilogue(&gen)

	// clean up and return the result
	code := strings.clone(strings.to_string(gen.builder))
	strings.builder_destroy(&gen.builder)
	return code
}
