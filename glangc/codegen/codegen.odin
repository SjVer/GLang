package glangc_codegen

import "core:strings"
import "core:time"

import c "../common"
import r "../report"
import t "../typing"

import g "generator"
import "generators"

TARGET_GENERATORS: map[string]g.Generator = {
	c.C_TARGET.name = generators.C_GENERATOR,
}

gen_code :: proc(tast: t.TAST, target: c.Target) -> string {
	assert(target.name in TARGET_GENERATORS)
	gen := TARGET_GENERATORS[target.name]

	// set things up
	gen.target = target
	gen.builder = strings.builder_make()
	gen.indent_level = 0
	gen.indent_str = "    "

	// prelude
	g.gprintfcln(&gen, "Generated by glangc")
	year, month, day := time.date(time.now())
	hours, mins, secs := time.clock_from_time(time.now())
	g.gprintfcln(
		&gen, "time: %02d-%02d-%04d %02d:%02d:%02d",
		day, month, year, hours, mins, secs,
	)
	g.gprintfcln(&gen, "target: %s", gen.target.name)
	g.gprintfcln(&gen, "see: https://github.com/SjVer/GLang")
	gen.gen_prelude(&gen)

	// codegen for each TAST item
	for decl in tast.decls {
		g.gprintln(&gen)
		g.gprintfln(&gen, gen.comment_fmt, r.span_to_string(decl.span, true))

		switch decl in decl.decl {
			case t.Builtin:
				gen.gen_builtin(&gen, decl)
			case t.Global:
				gen.gen_global(&gen, decl)
			case t.Function:
				gen.gen_function(&gen, decl)
		}
	}

	// epilogue
	gen.gen_epilogue(&gen)

	// clean up and return the result
	code := strings.clone(strings.to_string(gen.builder))
	strings.builder_destroy(&gen.builder)
	return code
}
